/**
 * Module dependencies.
 */

var utils = require('../utils/utils')
  , string = utils.string
  , ok = utils.ok
  , invoke = utils.invoke
  , error = utils.error;

/**
 * GET <key>
 */

exports.get = function(key,cb){
  var obj = this.lookup(string(key));
  invoke(cb,ok(obj));
};

/**
 * GETSET <key> <val>
 */

exports.getset = function(key, val, cb){
  var key = string(key)
    , obj = this.lookup(key);

  this.db.data[key] = { type: 'string', val: val };
  
  invoke(cb,ok(get(key)));
};

/**
 * SET <key> <str>
 */

(exports.set = function(key, str,cb){
  key = string(key);
  this.db.data[key] = { val: str, type: 'string' };
  invoke(cb,ok(true));
}).mutates = true;

/**
 * SETNX <key> <val>
 */

(exports.setnx = function(key, val,cb){
  key = string(key);
  if (this.lookup(key)) return false;
  this.db.data[key] = { type: 'string', val: val };
  invoke(cb,ok(true));
}).mutates = true;

/**
 * SETEX <key> <seconds> <val>
 */

(exports.setex = function(key, seconds, val,cb){
  var key = string(key);

  this.db.data[key] = {
      type: 'string'
    , val: val
    , expires: Date.now() + (string(seconds) * 1000)
  };
  
  invoke(cb,ok(true));
}).mutates = true;

/**
 * INCR <key>
 */

(exports.incr = function(key,cb){
  var key = string(key)||'',obj = this.lookup(key);

  if (!obj) {
    this.db.data[key] = { type: 'string', val: 1 };
    invoke(cb,ok(1));
  } else if ('string' == obj.type) {
    if (Buffer.isBuffer(obj.val)) obj.val = +string(obj.val);
    if (isNaN(obj.val))  invoke(cb,utils.errortype());
    invoke(cb,ok(++obj.val));
  } else {
  	invoke(cb,utils.errortype());
  }
}).mutates = true;

/**
 * INCRBY <key> <num>
 */

(exports.incrby = function(key, num,cb){
  var key = string(key)
    , obj = this.lookup(key)
    , num = +string(num);

  if (isNaN(num))  invoke(cb,utils.errortype());

  if (!obj) {
    obj = this.db.data[key] = { type: 'string', val: num };
    return (obj.val);
  } else if ('string' == obj.type) {
    if (Buffer.isBuffer(obj.val)) obj.val = +string(obj.val);
    if (isNaN(obj.val)) invoke(cb,utils.errortype());
    invoke(cb,ok(obj.val += num));
  } else {
    invoke(cb,utils.errortype());
  }
}).mutates = true;

/**
 * DECRBY <key> <num>
 */

(exports.decrby = function(key, num,cb){
  var key = string(key)
    , obj = this.lookup(key)
    , num = +string(num);

  if (isNaN(num)) invoke(cb,utils.errorrange());;;

  if (!obj) {
    obj = this.db.data[key] = { type: 'string', val: -num };
    return (obj.val);
  } else if ('string' == obj.type) {
    if (Buffer.isBuffer(obj.val)) obj.val = +string(obj.val);
    if (isNaN(obj.val)) invoke(cb,utils.errorrange());;;
    return (obj.val -= num);
  } else {
    invoke(cb,utils.errortype());
  }
}).mutates = true;

/**
 * DECR <key>
 */

(exports.decr = function(key,cb){
  var key = string(key)
    , obj = this.lookup(key);

  if (!obj) {
    this.db.data[key] = { type: 'string', val: -1 };
    invoke(cb,ok(-1));
  } else if ('string' == obj.type) {
    if (Buffer.isBuffer(obj.val)) obj.val = +string(obj.val);
    if (isNaN(obj.val))  invoke(cb,utils.errorrange());;;
    invoke(cb,ok(--obj.val));
  } else {
    invoke(cb,utils.errortype());
  }
}).mutates = true;

/**
 * STRLEN <key>
 */

exports.strlen = function(key){
  var key = string(key)
    , val = this.lookup(key);

  if (val) {
    return (val.length);
  } else if ('string' == this.keyType(key)) {
  	invoke(cb,ok(0));
  } else {
    invoke(cb,utils.errortype());
  }
};

/**
 * APPEND <key> <str>
 */

(exports.append = function(key, str,cb){
  var key = string(key)
    , obj = this.lookup(key);

  if (obj && 'string' != obj.type)  invoke(cb,utils.errortype());

  if (obj) {
    if (!Buffer.isBuffer(obj.val)) obj.val = new Buffer(obj.val.toString());
    var offset = obj.val.length
      , len = offset + str.length
      , buf = new Buffer(len);
    obj.val.copy(buf);
    str.copy(buf, offset);
    obj.val = buf;
    this.db.data[key] = obj;
    invoke(cb,ok(len));
  } else {
    this.db.data[key] = { type: 'string', val: str };
    invoke(cb,ok(str.length));
  }
}).mutates = true;

/**
 * SETRANGE <key> <offset> <str>
 */

(exports.setrange = function(key, offset, str,cb){
  var obj = this.lookup(string(key))
    , offset = +string(offset);


  if (!obj) {
    // TODO: finish
  } else if ('string' == obj.type) {
    str.copy(obj.val, offset);
    invoke(cb,ok(obj.val.length));
  } else {
    invoke(cb,utils.errortype());
  }
}).mutates;

/**
 * get range from list the key
 * GETRANGE <key> <from> <to>
 */

exports.substr = function(key, from, to,cb){
  var obj = this.lookup(string(key))
    , from = +string(from)
    , to = +string(to);

  if (!obj) return null;
  if ('string' != obj.type)  invoke(cb,utils.errortype());

  var len = obj.val.length;

  if (isNaN(from))  invoke(cb,utils.errortype());
  if (isNaN(to))  invoke(cb,utils.errortype());

  // Clamp positive
  if (from > len) from = len;
  if (to > len) to = len;

  // Negative
  if (from < 0) from = len + from;
  if (to < 0) to = len + to;

  // Clamp negative
  if (to < 0) to = 0;
  if (from < 0) from = 0;

  invoke(cb,ok(obj.val.slice(from, to + 1)));
};

/**
 * MGET <key>+
 */

(exports.mget = function(keys,cb){
  var len = keys.length;
  var list = [];
  for (var i = 0; i < len; ++i) {
    var obj = this.lookup(keys[i]);
    list.push(obj);
  }
  invoke(cb,ok(list));
}).multiple = 1;

/**
 * MSET (<key> <val>)+
 */

exports.mset = function(strs,cb){
  var len = strs.length
    , key
    , val;

  for (var i = 0; i < len; ++i) {
    key = string(strs[i++]);
    this.db.data[key] = { type: 'string', val: strs[i] };
  }
  invoke(cb,ok(true));
};

exports.mset.multiple = 2;
exports.mset.mutates = true;

/**
 * MSETNX (<key> <val>)+
 */

exports.msetnx = function(strs,cb){
  var len = strs.length
    , keys = []
    , key
    , val;

  // Ensure none exist
  for (var i = 0; i < len; ++i) {
    keys[i] = key = string(strs[i++]);
    if (this.lookup(key)) invoke(cb,ok(false));;
  }

  // Perform sets
  for (var i = 0; i < len; i += 2) {
    key = keys[i];
    this.db.data[key] = { type: 'string', val: strs[i] }
  }
  
  invoke(cb,ok(true));
};

exports.msetnx.multiple = 2;
exports.msetnx.mutates = true;
